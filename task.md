
# Тестовое задание для вакансии «Системный программист С»

**Версия задания:** 10.02.25г.

## Условия задания

Требуется разработать утилиту для анализа бинарных данных.

### Структура данных
```c
typedef struct StatData {
    long id;
    int count;
    float cost;
    unsigned int primary:1;
    unsigned int mode:3;
} StatData;
```

### Технические требования
- Использовать стандартную библиотеку C и/или системные вызовы Linux
- Предложить пути оптимизации алгоритмов обработки данных
- Размер массивов: 0-100000 элементов
- Объем доступной ОЗУ: ≥64Мб
- Сборка: make/CMake/meson
- Компилятор: gcc/clang
- Архитектура: x86_64, ОС: Linux
- Стандарт языка C: любой удобный

### Критерии оценки
- Работоспособность решений (включая компиляцию)
- Эффективность алгоритма в `JoinDump()`
- Покрытие кода тестами
- Обработка ошибок

## Функциональные требования

### 1. Сериализация и десериализация

#### `StoreDump()`
Функция сохранения массива `StatData` в файл.

**Параметры:**
- Массив `StatData` произвольной длины
- Путь к файлу для сохранения

#### `LoadDump()`
Функция чтения массива `StatData` из файла (созданного `StoreDump`).

### 2. Обработка данных

#### `JoinDump()`
Функция объединения двух массивов `StatData` с уникальными `id`.

**Правила объединения:**
- `count` и `cost` суммируются
- `primary` = 0, если хотя бы в одном элементе 0
- `mode` = максимальное значение из двух элементов

#### `SortDump()`
Функция сортировки массива `StatData` по возрастанию `cost`.

### 3. Утилита обработки данных

**Аргументы:**
1. Путь к первому файлу
2. Путь ко второму файлу
3. Путь к файлу результата

**Алгоритм работы:**
1. Считать оба файла
2. Объединить данные (`JoinDump`)
3. Отсортировать результат (`SortDump`)
4. Напечатать первые 10 записей в виде таблицы
5. Сохранить результат в файл

**Формат вывода:**
| Поле       | Формат                |
|------------|-----------------------|
| id         | Шестнадцатеричный     |
| count      | Десятичный            |
| cost       | Экспоненциальный (3 знака после запятой) |
| primary    | "y" (1) или "n" (0)   |
| mode       | Бинарный              |

### 4. Утилита тестирования

**Функционал:**
- Генерация тестовых файлов
- Запуск утилиты обработки
- Сравнение результата с эталоном
- Вывод отчета:
  - Сообщения об ошибках (stderr)
  - Время выполнения и список тестов (stdout)

## Пример тестовых данных

### Исходные данные
```c
const StatData case_1_in_a[2] = {
    {.id = 90889, .count = 13, .cost = 3.567, .primary = 0, .mode=3},
    {.id = 90089, .count = 1, .cost = 88.90, .primary = 1, .mode=0}
};

const StatData case_1_in_b[2] = {
    {.id = 90089, .count = 13, .cost = 0.011, .primary = 0, .mode=2},
    {.id = 90189, .count = 1000, .cost = 1.00003, .primary = 1, .mode=2}
};
```

### Ожидаемый результат
```c
const StatData case_1_out[3] = {
    {.id = 90189, .count = 1000, .cost = 1.00003, .primary = 1, .mode = 2},
    {.id = 90889, .count = 13, .cost = 3.567, .primary = 0, .mode = 3},
    {.id = 90089, .count = 14, .cost = 88.911, .primary = 0, .mode = 2}
};
```

## Примечание
При разработке следует уделить особое внимание:
- Оптимизации алгоритма объединения данных
- Полному покрытию тестами
- Корректной обработке ошибок
- Читаемости и поддерживаемости кода
```